// Dafny program verifier version 2.2.30705.1126, Copyright (c) 2003-2012, Microsoft.
// Command Line Options: /compile:0 /vcsMaxKeepGoingSplits:2 /dprint:out.dfy.tmp -nologo -logPrefix:Dafny1 UltraFilter.dfy
// UltraFilter.dfy

class UltraFilter<G(==)> {
  static function IsFilter(f: set<set<G>>, S: set<G>): bool
  {
    (forall A, B :: 
      A in f &&
      A <= B ==>
        B in f) &&
    (forall C, D :: 
      C in f &&
      D in f ==>
        C * D in f) &&
    S in f &&
    {} !in f
  }

  static function IsUltraFilter(f: set<set<G>>, S: set<G>): bool
  {
    IsFilter(f, S) &&
    forall g :: 
      IsFilter(g, S) &&
      f <= g ==>
        f == g
  }

  method Theorem(f: set<set<G>>, S: set<G>, M: set<G>, N: set<G>)
    requires IsUltraFilter(f, S);
    requires M + N in f;
    ensures M in f || N in f;
  {
    if (M !in f) {
      var h := H(f, S, M);
      Lemma_HIsFilter(h, f, S, M);
      Lemma_FHOrdering0(h, f, S, M);
    }
  }

  method H(f: set<set<G>>, S: set<G>, M: set<G>)
      returns (h: set<set<G>>)
    ensures forall X :: X in h <==> M + X in f;

  method Lemma_HIsFilter(h: set<set<G>>, f: set<set<G>>, S: set<G>, M: set<G>)
    requires IsFilter(f, S);
    requires forall X :: X in h <==> M + X in f;
    requires M !in f;
    ensures IsFilter(h, S);
  {
    assume forall A, B :: A in h && A <= B ==> B in h;
    assume forall C, D :: C in h && D in h ==> C * D in h;
    Lemma_H2(h, f, S, M);
    Lemma_H3(h, f, S, M);
  }

  method Lemma_H0(h: set<set<G>>, f: set<set<G>>, S: set<G>, M: set<G>, A: set<G>, B: set<G>)
    requires IsFilter(f, S);
    requires forall X :: X in h <==> M + X in f;
    requires A in h && A <= B;
    ensures B in h;
  {
    assert M + A <= M + B;
  }

  method Lemma_H1(h: set<set<G>>, f: set<set<G>>, S: set<G>, M: set<G>, C: set<G>, D: set<G>)
    requires IsFilter(f, S);
    requires forall X :: X in h <==> M + X in f;
    requires C in h && D in h;
    ensures C * D in h;
  {
    assert (M + C) * (M + D) == M + C * D;
  }

  method Lemma_H2(h: set<set<G>>, f: set<set<G>>, S: set<G>, M: set<G>)
    requires IsFilter(f, S);
    requires forall X :: X in h <==> M + X in f;
    ensures S in h;
  {
    assume M <= S;
    assert M + S == S;
  }

  method Lemma_H3(h: set<set<G>>, f: set<set<G>>, S: set<G>, M: set<G>)
    requires IsFilter(f, S);
    requires forall X :: X in h <==> M + X in f;
    requires M !in f;
    ensures {} !in h;
  {
    assert M + {} == M;
  }

  method Lemma_FHOrdering0(h: set<set<G>>, f: set<set<G>>, S: set<G>, M: set<G>)
    requires IsFilter(f, S);
    requires forall X :: X in h <==> M + X in f;
    requires IsFilter(h, S);
    ensures f <= h;
  {
    assume forall Y :: Y in f ==> Y in h;
    assume f <= h;
  }

  method Lemma_FHOrdering1(h: set<set<G>>, f: set<set<G>>, S: set<G>, M: set<G>, Y: set<G>)
    requires IsFilter(f, S);
    requires forall X :: X in h <==> M + X in f;
    ensures Y in f ==> Y in h;
  {
    assert Y <= M + Y;
  }
}
